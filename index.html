<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Jarvis</title>
</head>
<body>
  <h1>Jarvis with OpenAI</h1>

  <h2>Record Voice</h2>
  <button id="startRecording">Start Recording</button>
  <button id="stopRecording" disabled>Stop Recording</button>
  <p id="recordingStatus"></p>
  <p id="transcribedText">Transcribed text will appear here</p>

  <h2>Type Text</h2>
  <textarea id="textInput" rows="4" cols="50"></textarea>
  <button id="submitText">Submit Text</button>

  <h2>Response</h2>
  <p id="responseText">Response text will appear here</p>
  <button id="playResponse">Play Response</button>

  <script src="/socket.io/socket.io.js"></script>
  <!--BEGINNING OF A GREAT SCRIPT-->
  
  <script>
    // Add a simple Buffer implementation for browser
    const Buffer = {
      from: function (base64, encoding) {
        const binary = atob(base64);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          buffer[i] = binary.charCodeAt(i);
        }
        return buffer;
      },
    };
  
    // Minimal implementation of audioBufferToWav
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const bitsPerSample = 16;
  
      const bufferLength = buffer.length;
      const wavDataLength = bufferLength * numChannels * 2;
      const totalLength = 44 + wavDataLength;
      const wavBuffer = new ArrayBuffer(totalLength);
      const view = new DataView(wavBuffer);
  
      function writeString(s, offset) {
        for (let i = 0; i < s.length; i++) {
          view.setUint8(offset + i, s.charCodeAt(i));
        }
      }
  
      // RIFF identifier
      writeString("RIFF", 0);
      // file length
      view.setUint32(4, totalLength - 8, true);
      // RIFF type
      writeString("WAVE", 8);
      // format chunk identifier
      writeString("fmt ", 12);
      // format chunk length
      view.setUint32(16, 16, true);
      // sample format (PCM)
      view.setUint16(20, 1, true);
      // channel count
      view.setUint16(22, numChannels, true);
      // sample rate
      view.setUint32(24, sampleRate, true);
      // byte rate
      view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
      // block align
      view.setUint16(32, numChannels * (bitsPerSample / 8), true);
      // bits per sample
      view.setUint16(34, bitsPerSample, true);
      // data chunk identifier
      writeString("data", 36);
      // data chunk length
      view.setUint32(40, wavDataLength, true);
  
      // Write the PCM samples
      const volume = 1;
      let index = 44;
      for (let i = 0; i < bufferLength; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          const sample = buffer.getChannelData(channel)[i] * (volume * 32768);
          view.setInt16(index, sample, true);
          index += 2;
        }
      }
  
      return new Blob([view], { type: "audio/wav" });
    }
  </script>
  
  <!--ENDING OF GREAT SCRIPT-->
  
  <script src="client.js"></script>
</body>
</html>
